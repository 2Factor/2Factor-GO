/*
 * m2factor
 *
 * This file was automatically generated for 2Factor by APIMATIC BETA v2.0 on 02/18/2016
 */
package smsotp

import(
    "encoding/json"
    "github.com/apimatic/unirest-go"
    "m2factor"
    "m2factor/apihelper"
    "m2factor/models"
)
/*
 * Client structure as interface implementation
 */
type SMSOTP_IMPL struct { }

/**
 * This endpoint is used to check SMS OTP balance
 * @param    string        apiKey      parameter: Required
 * @return	Returns the *models.CheckSmsBalanceModel response from the API call
 */
func (me *SMSOTP_IMPL) GetCheckSMSBalance (
            apiKey string) (*models.CheckSmsBalanceModel, error) {
    //the base uri for api requests
    queryBuilder := m2factor.BASEURI;
        
    //prepare query string for API call
    queryBuilder = queryBuilder + "/API/V1/{api_key}/BAL/SMS"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    queryBuilder, err = apihelper.AppendUrlWithTemplateParameters(queryBuilder, map[string]interface{} {
        "api_key" : apiKey,
    }) 
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    queryBuilder, err = apihelper.CleanUrl(queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "2Factor",
        "accept" : "application/json",
    }

    //prepare API request
    request := unirest.Get(queryBuilder, headers)
    //and invoke the API call request to fetch the response
    response, err := unirest.AsString(request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (response.Code < 200) || (response.Code > 206) { //[200,206] = HTTP OK
        err = apihelper.NewAPIError("HTTP Response Not OK" , response.Code, response.RawBody)
    }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }
    
    //returning the response
    var retVal *models.CheckSmsBalanceModel = &models.CheckSmsBalanceModel{}
    err = json.Unmarshal(response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * This endpoint is used to send Auto Generated SMS OTP to India
 * @param    string        apiKey           parameter: Required
 * @param    string        phoneNumber      parameter: Required
 * @return	Returns the *models.SendingSmsOtpAutoGeneratedOtpModel response from the API call
 */
func (me *SMSOTP_IMPL) GetSendingSMSOTPAutoGeneratedOTP (
            apiKey string,
            phoneNumber string) (*models.SendingSmsOtpAutoGeneratedOtpModel, error) {
    //the base uri for api requests
    queryBuilder := m2factor.BASEURI;
        
    //prepare query string for API call
    queryBuilder = queryBuilder + "/API/V1/{api_key}/SMS/{phone_number}/AUTOGEN"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    queryBuilder, err = apihelper.AppendUrlWithTemplateParameters(queryBuilder, map[string]interface{} {
        "api_key" : apiKey,
        "phone_number" : phoneNumber,
    }) 
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    queryBuilder, err = apihelper.CleanUrl(queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "2Factor",
        "accept" : "application/json",
    }

    //prepare API request
    request := unirest.Get(queryBuilder, headers)
    //and invoke the API call request to fetch the response
    response, err := unirest.AsString(request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (response.Code < 200) || (response.Code > 206) { //[200,206] = HTTP OK
        err = apihelper.NewAPIError("HTTP Response Not OK" , response.Code, response.RawBody)
    }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }
    
    //returning the response
    var retVal *models.SendingSmsOtpAutoGeneratedOtpModel = &models.SendingSmsOtpAutoGeneratedOtpModel{}
    err = json.Unmarshal(response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * This endpoint is used to send Custom SMS OTP to India
 * @param    string        apiKey           parameter: Required
 * @param    string        otp              parameter: Required
 * @param    string        phoneNumber      parameter: Required
 * @return	Returns the *models.SendingSmsOtpModel response from the API call
 */
func (me *SMSOTP_IMPL) GetSendingSMSOTPCustomOTP (
            apiKey string,
            otp string,
            phoneNumber string) (*models.SendingSmsOtpModel, error) {
    //the base uri for api requests
    queryBuilder := m2factor.BASEURI;
        
    //prepare query string for API call
    queryBuilder = queryBuilder + "/API/V1/{api_key}/SMS/{phone_number}/{otp}"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    queryBuilder, err = apihelper.AppendUrlWithTemplateParameters(queryBuilder, map[string]interface{} {
        "api_key" : apiKey,
        "otp" : otp,
        "phone_number" : phoneNumber,
    }) 
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    queryBuilder, err = apihelper.CleanUrl(queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "2Factor",
        "accept" : "application/json",
    }

    //prepare API request
    request := unirest.Get(queryBuilder, headers)
    //and invoke the API call request to fetch the response
    response, err := unirest.AsString(request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (response.Code < 200) || (response.Code > 206) { //[200,206] = HTTP OK
        err = apihelper.NewAPIError("HTTP Response Not OK" , response.Code, response.RawBody)
    }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }
    
    //returning the response
    var retVal *models.SendingSmsOtpModel = &models.SendingSmsOtpModel{}
    err = json.Unmarshal(response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

/**
 * This endpoint is useful in verifying user entered OTP with sent OTP
 * @param    string        apiKey         parameter: Required
 * @param    string        otpInput       parameter: Required
 * @param    string        sessionId      parameter: Required
 * @return	Returns the *models.VerifyOtpInputModel response from the API call
 */
func (me *SMSOTP_IMPL) GetVerifySMSOTPInput (
            apiKey string,
            otpInput string,
            sessionId string) (*models.VerifyOtpInputModel, error) {
    //the base uri for api requests
    queryBuilder := m2factor.BASEURI;
        
    //prepare query string for API call
    queryBuilder = queryBuilder + "/API/V1/{api_key}/SMS/VERIFY/{session_id}/{otp_input}"

    //variable to hold errors
    var err error = nil
    //process optional query parameters
    queryBuilder, err = apihelper.AppendUrlWithTemplateParameters(queryBuilder, map[string]interface{} {
        "api_key" : apiKey,
        "otp_input" : otpInput,
        "session_id" : sessionId,
    }) 
    if err != nil {
        //error in template param handling
        return nil, err
    }

    //validate and preprocess url
    queryBuilder, err = apihelper.CleanUrl(queryBuilder)
    if err != nil {
        //error in url validation or cleaning
        return nil, err
    }

    //prepare headers for the outgoing request
    headers := map[string]interface{} {
        "user-agent" : "2Factor",
        "accept" : "application/json",
    }

    //prepare API request
    request := unirest.Get(queryBuilder, headers)
    //and invoke the API call request to fetch the response
    response, err := unirest.AsString(request);
    if err != nil {
        //error in API invocation
        return nil, err
    }

    //error handling using HTTP status codes
    if (response.Code < 200) || (response.Code > 206) { //[200,206] = HTTP OK
        err = apihelper.NewAPIError("HTTP Response Not OK" , response.Code, response.RawBody)
    }
    if(err != nil) {
        //error detected in status code validation
        return nil, err
    }
    
    //returning the response
    var retVal *models.VerifyOtpInputModel = &models.VerifyOtpInputModel{}
    err = json.Unmarshal(response.RawBody, &retVal)

    if err != nil {
        //error in parsing
        return nil, err
    }
    return retVal, nil
}

